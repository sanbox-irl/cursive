//! # Cursive
//!
//! [Cursive] is a [TUI] library - it lets you easily build rich interfaces
//! for use in a terminal.
//!
//! [Cursive]: https://github.com/gyscos/cursive
//! [TUI]: https://en.wikipedia.org/wiki/Text-based_user_interface
//!
//! ## Getting started
//!
//! * Every application should start with a [`Cursive`] object. It is the main
//!   entry-point to the library.
//! * A declarative phase then describes the structure of the UI by adding
//!   views and configuring their behaviours.
//! * Finally, the event loop is started by calling [`Cursive::run`].
//!
//! ## Views
//!
//! Views are the main components of a cursive interface.
//! The [`views`] module contains many views to use in your
//! application; if you don't find what you need, you may also implement the
//! [`View`] trait and build your own.
//!
//! ## Callbacks
//!
//! Cursive is callback-driven: it reacts to events generated by user input.
//!
//! During the declarative phase, callbacks are set to trigger on specific
//! events. These functions usually take an `&mut Cursive` argument, allowing
//! them to modify the view tree at will.
//!
//! ## Examples
//!
//! ```rust
//! use cursive::Cursive;
//! use cursive::views::TextView;
//!
//! let mut siv = Cursive::dummy();
//!
//! siv.add_layer(TextView::new("Hello World!\nPress q to quit."));
//!
//! siv.add_global_callback('q', |s| s.quit());
//!
//! siv.run();
//! ```
//!
//! ## Debugging
//!
//! The `Cursive` root initializes the terminal on creation, and does cleanups
//! on drop. While it is alive, printing to the terminal will not work
//! as expected, making debugging a bit harder.
//!
//! One solution is to redirect stderr to a file when running the application,
//! and log to it instead of stdout.
//!
//! Or you can use gdb as usual.
#![deny(missing_docs)]

pub use cursive_core::*;

mod utf8;

pub mod backends;

mod cursive_ext;
pub use cursive_ext::CursiveExt;

/// Creates a new Cursive root using one of the enabled backends.
///
/// Will use the first available backend from this list:
/// * BearLibTerminal
/// * Termion
/// * Crossterm
/// * Pancurses
/// * Ncurses
///
/// If none of these is enabled, it will default to a dummy backend.
///
/// # Panics
///
/// If the backend initialization fails.
pub fn default() -> Cursive {
    Cursive::default()
}

/// Creates a new Cursive root using a ncurses backend.
#[cfg(feature = "ncurses-backend")]
pub fn ncurses() -> std::io::Result<Cursive> {
    Cursive::ncurses()
}

/// Creates a new Cursive root using a pancurses backend.
#[cfg(feature = "pancurses-backend")]
pub fn pancurses() -> std::io::Result<Cursive> {
    Cursive::pancurses()
}

/// Creates a new Cursive root using a termion backend.
#[cfg(feature = "termion-backend")]
pub fn termion() -> std::io::Result<Cursive> {
    Cursive::termion()
}

/// Creates a new Cursive root using a crossterm backend.
#[cfg(feature = "crossterm-backend")]
pub fn crossterm() -> Result<Cursive, crossterm::ErrorKind> {
    Cursive::crossterm()
}

/// Creates a new Cursive root using a bear-lib-terminal backend.
#[cfg(feature = "blt-backend")]
pub fn blt() -> Cursive {
    Cursive::blt()
}

/// Creates a new Cursive root using a dummy backend.
///
/// Nothing will be output. This is mostly here for tests.
pub fn dummy() -> Cursive {
    Cursive::dummy()
}
